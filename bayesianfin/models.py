# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_garch_like_modelling.ipynb.

# %% auto 0
__all__ = ['garch_like_model']

# %% ../nbs/01_garch_like_modelling.ipynb 6
import arviz as az
import jax.numpy as jnp
import matplotlib.pyplot as plt
import numpy.typing as npt
import numpyro
import numpyro.distributions as dist
import polars as pl
import seaborn as sns
from jax import random
from numpyro.infer import MCMC, NUTS, Predictive
from tqdm import tqdm
from bayesianfin.simulation import Simulator
from bayesianfin.data import (
    QuantileTransformer,
    DataLoader,
    FeatureEngineer,
    LogReturn,
    Variance,
    Identity,
)

# %% ../nbs/01_garch_like_modelling.ipynb 7
az.style.use("arviz-darkgrid")

# %% ../nbs/01_garch_like_modelling.ipynb 17
def garch_like_model(
    present_value: npt.NDArray = None, past_values: dict[str, npt.NDArray] = None
) -> None:
    b_var = numpyro.sample("b_var", dist.Normal(0.0, 0.3))  # So it is positive

    coeffs = {}
    for col, s in feature_engineer.get_iterator("var_quantile"):
        param_name = feature_engineer.get_shift_pattern(col, s)
        coeffs[param_name] = numpyro.sample(f"param_{param_name}", dist.Exponential(50))

    # Handle prediction case
    len_observations = len(present_value) if present_value is not None else 1
    with numpyro.plate("data", len_observations):
        mu_var = b_var
        for col, s in feature_engineer.get_iterator("var_quantile"):
            param_name = feature_engineer.get_shift_pattern(col, s)
            mu_var += coeffs[param_name] * past_values[param_name]

    numpyro.sample("log_ret", dist.Normal(0, jnp.sqrt(mu_var)), obs=present_value)
