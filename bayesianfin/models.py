# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/garch_modelling.ipynb.

# %% auto 0
__all__ = ['garch_like_model']

# %% ../nbs/01_garch_like_modelling.ipynb 4
import arviz as az
import jax
import jax.numpy as jnp
import matplotlib.pyplot as plt
import numpy as np
import numpy.typing as npt
import numpyro
import numpyro.distributions as dist
import polars as pl
import seaborn as sns
from jax import random
from numpyro.contrib.control_flow import scan
from numpyro.infer import MCMC, NUTS, Predictive
from tqdm import tqdm

from bayesianfin.data import (
    DataLoader,
    FeatureEngineer,
    LogReturn,
    Variance,
    append_from_log_ret,
)

# %% ../nbs/01_garch_like_modelling.ipynb 5
az.style.use("arviz-darkgrid")

# %% ../nbs/01_garch_like_modelling.ipynb 16
def garch_like_model(
    present_value: npt.NDArray, past_values: dict[str, npt.NDArray]
) -> None:
    b_mu = numpyro.sample("b_mu", dist.Normal(0, 0.2))

    coeffs = {}
    for col, s in feature_engineer.get_iterator("log_ret"):
        param_name = feature_engineer.get_shift_pattern(col, s)
        coeffs[param_name] = numpyro.sample(
            f"param_{param_name}", dist.Normal(0.0, 0.1)
        )

    for col, s in feature_engineer.get_iterator("var"):
        param_name = feature_engineer.get_shift_pattern(col, s)
        coeffs[param_name] = numpyro.sample(f"param_{param_name}", dist.Exponential(50))

    # Handle prediction case
    len_observations = len(present_value) if present_value is not None else 1

    init_log_var = numpyro.sample("init_log_var", dist.Normal(0, 1))
    eps = numpyro.sample(
        "eps", dist.Normal(0, 1).expand([len_observations]).to_event(1)
    )

    b_var = numpyro.sample("b_var", dist.Normal(0, 0.2))
    b1 = numpyro.sample("b1", dist.Normal(0, 0.2))
    b2 = numpyro.sample("b2", dist.Normal(0, 0.2))

    def vol_transition(carry, eps_t):
        log_var_prev = carry
        log_var_t = b_var + b1 * log_var_prev + b2 * eps_t
        log_var_t = log_var_t.clip(-1, 5)
        return log_var_t, log_var_t

    _, log_vars = scan(vol_transition, init_log_var, eps)
    variance_array = jnp.exp(log_vars)
    std_array = jnp.sqrt(variance_array)

    mu = b_mu
    for col, s in feature_engineer.get_iterator("log_ret"):
        param_name = feature_engineer.get_shift_pattern(col, s)
        mu += coeffs[param_name] * past_values[param_name]
    with numpyro.plate("data", len_observations):
        numpyro.sample(
            "log_ret",
            dist.Normal(mu, std_array),
            obs=present_value,
        )


numpyro.render_model(
    garch_model,
    model_args=(
        present_value_train,
        past_values_train,
    ),
)
